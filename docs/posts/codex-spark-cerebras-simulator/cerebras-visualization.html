<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Cerebras Chip Visualization</title>
    <style>
      :root {
        --bg: #f3e8c9;
        --panel: #fbf3de;
        --ink: #3f2f1d;
        --subtle: #6e573d;
        --good: #b8852f;
        --good-soft: #d7b16a;
        --bad: #8c2f36;
        --repair: #5d9348;
        --io: #9c6b39;
        --path: #f6cc57;
        --mesh: #c7ad82;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        color: var(--ink);
        background: linear-gradient(160deg, #f6e8c5 0%, #f7f0d8 40%, #f6e8c5 100%);
        font-family: "Trebuchet MS", "Gill Sans", "Avenir Next", "Segoe UI", serif;
        overflow-wrap: break-word;
        word-break: break-word;
        scroll-behavior: smooth;
      }

      main {
        max-width: 1200px;
        margin: 0 auto;
        padding: 28px;
        width: 100%;
      }

      .title {
        margin: 0 0 10px;
        font-size: 32px;
        letter-spacing: 0.4px;
        line-height: 1.15;
        overflow-wrap: anywhere;
        word-break: break-word;
      }

      .subtitle {
        margin: 0;
        color: var(--subtle);
        max-width: 900px;
        overflow-wrap: anywhere;
        word-break: break-word;
      }

      .board {
        margin-top: 22px;
        display: grid;
        gap: 20px;
        grid-template-columns: minmax(0, 1fr);
        align-items: start;
      }

      .visual {
        display: flex;
        flex-direction: column;
      }

      .panel {
        background: var(--panel);
        border: 1px solid #e4cf9f;
        border-radius: 16px;
        box-shadow: 0 10px 34px rgba(58, 44, 24, 0.08);
        padding: 16px;
        min-width: 0;
        width: 100%;
        overflow: hidden;
        overflow-wrap: anywhere;
        word-break: break-word;
      }

      .visual {
        padding: 18px;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .chip-wrap {
        position: relative;
        width: 100%;
        aspect-ratio: 16 / 10;
        min-height: min(560px, 58vw);
        border-radius: 12px;
        overflow: hidden;
        display: grid;
        flex: 1;
      }

      #wafer {
        grid-area: 1 / 1;
        position: relative;
        width: 100%;
        height: 100%;
        display: block;
      }

      #wafer3d {
        grid-area: 1 / 1;
        position: relative;
        width: 100%;
        height: 100%;
        display: none;
      }

      .view-toggle {
        margin-bottom: 10px;
        display: flex;
        gap: 8px;
        flex-shrink: 0;
      }

      .view-toggle button {
        flex: 1;
        background: #7a5e3a;
      }

      .view-toggle .active {
        background: #b8852f;
      }

      .side {
        display: grid;
        gap: 14px;
        min-width: 0;
        width: 100%;
        position: sticky;
        top: 10px;
      }

      .control-head {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        min-width: 0;
      }

      .control-head h2 {
        margin: 0;
        font-size: 13px;
        color: #4d3920;
        text-transform: uppercase;
        letter-spacing: 0.4px;
        white-space: nowrap;
      }

      .control {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .row {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 8px;
        width: 100%;
        min-width: 0;
      }

      label {
        color: var(--subtle);
        font-size: 14px;
        min-width: 0;
        overflow-wrap: anywhere;
        word-break: break-word;
      }

      .value {
        font-size: 13px;
        color: var(--ink);
        min-width: 56px;
        text-align: right;
        white-space: nowrap;
        margin-left: auto;
      }

      input[type="range"] {
        width: 100%;
      }

      button {
        border: 0;
        border-radius: 10px;
        padding: 10px 12px;
        background: #b8852f;
        color: white;
        font-weight: 600;
        cursor: pointer;
        transition: transform 120ms ease, filter 120ms ease;
        white-space: nowrap;
      }

      button:hover {
        filter: brightness(1.05);
      }

      button:active {
        transform: translateY(1px);
      }

      button.secondary {
        background: #4d3920;
      }

      .btn-row {
        display: grid;
        gap: 8px;
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }

      .single-action {
        grid-template-columns: 1fr;
      }

      .action-bar {
        margin-top: 10px;
        margin-bottom: 6px;
      }

      .result-frame {
        background: #f8efce;
        border: 1px solid #e3ca97;
      }

      .result-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        margin: 6px 0 8px;
        color: #4d3920;
        font-size: 13px;
      }

      .result-meta span {
        background: #eadcb3;
        border-radius: 999px;
        padding: 4px 8px;
      }

      .result-bars {
        display: flex;
        align-items: flex-end;
        gap: 5px;
        min-height: 86px;
        padding: 8px;
        border-radius: 10px;
        border: 1px solid #e2ca99;
        background: #fffbea;
        overflow-x: auto;
        overflow-y: hidden;
      }

      .result-bar {
        width: 8px;
        min-height: 6px;
        border-radius: 6px 6px 2px 2px;
        opacity: 0.95;
      }

      .result-bar.success {
        background: #5d9348;
      }

      .result-bar.fail {
        background: #8c2f36;
      }

      .three-only-controls {
        display: none;
      }

      body.view-3d .three-only-controls {
        display: flex;
      }

      .status {
        margin-top: 4px;
        background: #fff9ea;
        border: 1px dashed #d9bd87;
        border-radius: 10px;
        padding: 10px;
        min-height: 70px;
        color: #4a3720;
        font-size: 14px;
        line-height: 1.4;
        hyphens: auto;
        overflow-wrap: anywhere;
        word-break: break-word;
      }

      .guide {
        border-left: 3px solid #b8852f;
        padding-left: 10px;
      }

      .micro-note {
        margin: 6px 0 0;
        color: #4e3b23;
        font-size: 12px;
        line-height: 1.35;
      }

      .mini-legend {
        margin: 10px 0 14px;
        display: grid;
        gap: 8px;
        grid-template-columns: repeat(auto-fit, minmax(210px, 1fr));
      }

      .mini-legend-item {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        background: #fff9ea;
        border: 1px solid #e2ccb7;
        border-radius: 999px;
        padding: 8px 10px;
        color: #4d3920;
        font-size: 12px;
        line-height: 1.2;
      }

      .mini-legend-chip {
        width: 12px;
        height: 12px;
        border-radius: 999px;
        border: 1px solid rgba(74, 47, 20, 0.35);
        flex-shrink: 0;
      }

      .stats {
        display: grid;
        gap: 10px;
        grid-template-columns: 1fr 1fr;
      }

      .kpi {
        background: #fff9ea;
        border: 1px solid #e2ccb7;
        border-radius: 10px;
        padding: 10px;
        word-break: break-word;
      }

      .kpi b {
        display: block;
        margin-top: 4px;
        font-size: 22px;
      }

      .legend {
        display: grid;
        gap: 8px;
      }

      .item {
        display: flex;
        gap: 8px;
        align-items: center;
        font-size: 14px;
      }

      .swatch {
        width: 14px;
        height: 14px;
        border-radius: 4px;
      }

      .notes {
        color: #4a3820;
        font-size: 14px;
        line-height: 1.5;
        margin: 4px 0 0;
        max-width: 100%;
        overflow-wrap: anywhere;
        word-break: break-word;
      }

      .notes p {
        margin: 0;
        font-weight: 600;
      }

      .notes ul {
        margin: 8px 0 0;
        max-width: 100%;
        padding-left: 18px;
      }

      .notes li {
        margin: 4px 0;
        overflow-wrap: anywhere;
        word-break: break-word;
      }

      .notes small {
        display: block;
        margin-top: 6px;
        color: #62482a;
        line-height: 1.4;
      }

      .guide {
        margin-top: 4px;
      }

      .hide-on-capture {
        display: block;
      }

      .tag {
        margin-top: 2px;
        display: inline-flex;
        align-items: center;
        gap: 6px;
        color: #4a3318;
        background: #e7d7b5;
        border-radius: 100px;
        padding: 5px 10px;
        font-size: 12px;
      }

      .control .row-range {
        align-items: center;
      }

      .range-caption {
        color: #62482a;
        font-size: 12px;
        margin-top: -2px;
        margin-bottom: -2px;
      }

      .flow-dot {
        display: inline-flex;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: var(--path);
        box-shadow: 0 0 0 3px rgba(253, 224, 71, 0.15);
        margin-right: 6px;
      }

      .links {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .links a {
        color: #6f4b16;
        font-size: 12px;
        text-decoration: none;
        background: #f0ddaf;
        padding: 5px 8px;
        border-radius: 7px;
        max-width: 100%;
        overflow-wrap: anywhere;
        word-break: break-word;
      }

      .links a:hover {
        text-decoration: underline;
      }

      .tile-tooltip {
        position: absolute;
        left: 0;
        top: 0;
        transform: translate(-2px, -10px);
        padding: 8px 10px;
        border-radius: 8px;
        border: 1px solid #d9bd87;
        background: #fff6d8;
        color: #3f2f1d;
        box-shadow: 0 10px 22px rgba(53, 40, 20, 0.18);
        font-size: 12px;
        line-height: 1.35;
        max-width: 220px;
        pointer-events: none;
        display: none;
        z-index: 4;
        white-space: nowrap;
      }

      .cell {
        cursor: help;
      }

      .link-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        display: inline-flex;
      }

      .good { fill: var(--good-soft); }
      .bad { fill: var(--bad); }
      .repair { fill: var(--repair); }
      .io { fill: var(--io); }
      .path { fill: var(--path) !important; }
      .flow { filter: drop-shadow(0 0 8px rgba(246, 204, 87, 0.72)); }
      .cluster-outline {
        stroke-width: 2.2;
        fill: none;
        stroke-dasharray: 4 3;
        opacity: 0.95;
        pointer-events: none;
      }
      .cluster-label {
        fill: #6e2a2a;
        font-size: 11px;
        font-weight: 700;
        pointer-events: none;
        text-anchor: middle;
      }

      body.capture-mode .hide-on-capture {
        display: none;
      }

      @media (max-width: 980px) {
        .board {
          grid-template-columns: 1fr;
        }

        .title {
          font-size: 26px;
        }

        main {
          padding: 16px 10px;
        }
      }

      @media (prefers-reduced-motion: no-preference) {
        .panel, .item, .btn-row, .status {
          animation: fadeIn 0.35s ease both;
        }
        .btn-row { animation-delay: 0.1s; }
        .control { animation-delay: 0.2s; }
        .status { animation-delay: 0.25s; }
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(6px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
    </style>
  </head>
  <body>
    <main>
      <h1 class="title">Cerebras Wafer-Scale Defect-Tolerance Simulator</h1>
      <p class="subtitle">
        An interactive systems view of how a wafer-scale chip stays operational when faults appear. Use the controls to stress defects, links, and remap budget and watch packet flow adapt.
      </p>
      <div class="mini-legend">
        <div class="mini-legend-item"><span class="mini-legend-chip" style="background: var(--good-soft);"></span>Healthy tile</div>
        <div class="mini-legend-item"><span class="mini-legend-chip" style="background: var(--repair);"></span>Repaired / remapped tile</div>
        <div class="mini-legend-item"><span class="mini-legend-chip" style="background: var(--bad);"></span>Defective tile</div>
        <div class="mini-legend-item"><span class="mini-legend-chip" style="background: var(--io);"></span>I/O edge</div>
        <div class="mini-legend-item"><span class="mini-legend-chip" style="background: var(--path);"></span>Active path</div>
      </div>

      <section class="board">
        <article class="panel visual">
          <div class="view-toggle">
            <button id="view2d" class="active">2D view</button>
            <button id="view3d">3D view</button>
          </div>
        <div class="btn-row action-bar">
            <button id="shuffle">Generate a new chip map</button>
            <button id="animate">Pulse one packet path</button>
        </div>
          <div class="micro-note hide-on-capture">Reliability simulation runs 40 randomized maps with current sliders and remap policy.</div>
          <div class="control-head three-only-controls">
            <h2>3D controls</h2>
            <button id="resetView" class="secondary">Reset 3D camera</button>
          </div>
          <div class="chip-wrap">
            <svg id="wafer" viewBox="0 0 980 620" aria-label="cerebras-chip-visualization"></svg>
            <canvas id="wafer3d" aria-label="cerebras-chip-3d-visualization"></canvas>
            <div id="tileTooltip" class="tile-tooltip" aria-live="polite"></div>
          </div>
        </article>

        <aside class="panel side">
          <div class="control">
            <div class="control-head">
              <h2>Display controls</h2>
              <label>
                <input type="checkbox" id="captureMode" checked />
                <span>Demo mode (hide long notes)</span>
              </label>
            </div>
            <label>
              <input type="checkbox" id="autoRotate3d" checked />
              <span>Auto-rotate 3D scene</span>
            </label>
            <label>
              <input type="checkbox" id="showClusters" checked />
              <span>Show defect cluster outlines</span>
            </label>
          </div>

          <div class="control">
            <div class="row">
              <label for="defectRate">Manufacturing tile defects: <span id="defectLabel"></span></label>
              <span id="defectValue" class="value"></span>
            </div>
            <input id="defectRate" type="range" min="0" max="0.4" step="0.01" value="0.12" />
          </div>

          <div class="control">
            <div class="row">
              <label for="linkFaultRate">Inter-tile link defects: <span id="linkDefectLabel"></span></label>
              <span id="linkDefectValue" class="value"></span>
            </div>
            <input id="linkFaultRate" type="range" min="0" max="0.2" step="0.01" value="0.06" />
          </div>

          <div class="control">
            <div class="row">
              <label for="repairBudget">Spare-core remap budget (percent): <span id="repairBudgetLabel"></span></label>
              <span id="repairBudgetValue" class="value"></span>
            </div>
            <input id="repairBudget" type="range" min="0" max="20" step="1" value="7" />
          </div>

          <div class="control">
            <label>
              <input type="checkbox" id="allowRepair" checked />
              <span>Enable cluster remap for small defect groups</span>
            </label>
            <label>
              <input type="checkbox" id="pulseLoop" />
              <span>Loop packet pulse for continuous demo capture</span>
            </label>
            <label>
              <input type="checkbox" id="showMesh" checked />
              <span>Show mesh links</span>
            </label>
          </div>

          <div class="control">
            <div class="row row-range">
              <label for="pulseSpeed">Packet pulse speed: <span id="pulseSpeedLabel"></span></label>
              <span id="pulseSpeedValue" class="value"></span>
            </div>
            <input id="pulseSpeed" type="range" min="30" max="220" step="10" value="95" />
            <div class="range-caption"><span class="flow-dot"></span>Lower number = faster motion.</div>
          </div>

          <div class="control">
            <div class="btn-row single-action">
              <button id="runSimulation">Run reliability simulation</button>
            </div>
          </div>

          <div class="status" id="status">Ready</div>

          <div class="control result-frame">
            <div class="control-head">
              <h2>Reliability run visual</h2>
            </div>
            <div class="result-meta">
              <span id="reliabilitySuccessStat">Success: —</span>
              <span id="reliabilityFailStat">Fail: —</span>
              <span id="reliabilityPathStat">Avg route: —</span>
            </div>
            <div class="result-bars" id="reliabilityBars" aria-label="reliability run chart"></div>
          </div>

          <div class="notes guide">
            <p>Demo script</p>
            <ul>
              <li><b>Demo flow:</b> Generate chip map → pulse packet route.</li>
              <li><b>Demo mode:</b> enable <b>Loop packet pulse</b> and tune speed while narrating.</li>
              <li><b>Readout:</b> status bar and KPIs update after packet path pulses.</li>
              <li><b>What to watch:</b> repaired/active path, blocked routes, and cluster repair behavior under pressure.</li>
            </ul>
          </div>

          <div class="notes">
            <p>Legend</p>
            <ul>
            <li><b>Gold tile:</b> healthy compute tile.</li>
            <li><b>Olive-amber tile:</b> remapped/replaced tile from spare-capacity planning.</li>
            <li><b>Muted rust tile:</b> defective tile (not available).</li>
            <li><b>Dark line:</b> failed inter-tile link.</li>
            <li><b>Amber path:</b> active packet route for this map.</li>
            </ul>
          </div>

          <div class="stats">
            <div class="kpi">
              Healthy tiles
              <b id="healthyCount">—</b>
            </div>
            <div class="kpi">
              Repaired tiles
              <b id="repairCount">—</b>
            </div>
            <div class="kpi">
              Faulty links
              <b id="linkCount">—</b>
            </div>
            <div class="kpi">
              Routed packet
              <b id="pathLength">—</b>
            </div>
            <div class="kpi">
              Utilization
              <b id="utilization">—</b>
            </div>
            <div class="kpi">
              Remap utilization
              <b id="remapUtil">—</b>
            </div>
            <div class="kpi">
              Reliability (40 runs)
              <b id="reliabilityRate">—</b>
            </div>
          </div>

          <div class="legend">
            <div class="item"><span class="swatch" style="background:var(--panel);border:1px dashed var(--bad);"></span>Defect cluster outline</div>
            <div class="item"><span class="swatch" style="background:var(--mesh);border:1px dashed var(--ink);"></span>Mesh link overlay</div>
            <div class="item"><span class="swatch" style="background:var(--bad)"></span>Bad fabric link</div>
          </div>
          <div class="notes hide-on-capture">
            <p>What this depicts</p>
            <ul>
              <li>Each tile is a simplified compute/fabric region with local SRAM and packet-style dataflow behavior.</li>
              <li>Modeled as one continuous wafer-scale die, with faults and link failures injected per control settings.</li>
              <li>Data moves only across healthy neighboring tiles and healthy links; failed links force reroutes.</li>
              <li>Remap uses local repair clusters + criticality-aware scoring, plus a spare tile budget.</li>
              <li>Accuracy note: this is a concept-level simulator, not a full power/timing/clock-domain model.</li>
              <li>Built for real-time interaction and systems-level understanding. Exact architecture details are in source links.</li>
            </ul>
          </div>

          <div class="notes hide-on-capture">
            <p>Source notes (from cited materials)</p>
            <ul>
              <li>Wafer-scale size: WSE-3 is reported as ~46,225 mm² vs a H100-like GPU at ~814 mm².</li>
              <li>Core size argument: WSE-3 core area is cited around ~0.05 mm² (about 100x smaller than an H100-style ~6.2 mm² SM core).</li>
              <li>Yield comparison framing (blog): one 46,225 mm² wafer-scale chip per 300mm wafer vs ~72 GPU dies for an 814 mm² 5nm-style chip in their walkthrough example.</li>
              <li>Manufacturing geometry context: conventional wafers are typically diced into many reticle-sized dies; WSE uses field stitching and keeps one contiguous active wafer-scale array.</li>
              <li>Defect tolerance outcome: the model reflects small fault domains + local rerouting + limited spare capacity, then evaluates path completion under repeated randomized runs.</li>
              <li>WSI fabric behavior (IEEE Micro): shorter on-chip links are modeled as local inter-tile links; failed links can block mesh paths and force alternate local routing in this model.</li>
              <li>Cerebras WSE-3 reporting: ~93% usable silicon area and ~900,000 active cores (from the public WSE-3 discussion).</li>
              <li>Yield framing in this page is a simplification, meant to show concept-level effects of defect clusters, links, and remap budget.</li>
            </ul>
          </div>

          <span class="tag hide-on-capture">Based on public Cerebras defect-tolerance material</span>
          <div class="links hide-on-capture">
            <a href="https://www.cerebras.ai/blog/100x-defect-tolerance-how-cerebras-solved-the-yield-problem" target="_blank" rel="noreferrer">Cerebras blog</a>
            <a href="https://8968533.fs1.hubspotusercontent-na2.net/hubfs/8968533/IEEE%20Micro%202021-11%20Path%20to%20Wafer-Scale%20Integration.pdf" target="_blank" rel="noreferrer">IEEE Micro paper</a>
            <a href="https://cdn.sanity.io/files/e4qjo92p/production/b3779b8136a3a03a7b31913cb680e33d68423e58.pdf" target="_blank" rel="noreferrer">WSI report</a>
            <a href="https://cdn.sanity.io/files/e4qjo92p/production/2d7fa58e3b820715664bcf42097e86c05070c161.pdf" target="_blank" rel="noreferrer">Further details</a>
          </div>
        </aside>
      </section>
    </main>

    <script src="https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.min.js"></script>
    <script>
      const rows = 18;
      const cols = 32;
      const tileSize = 28;
      const gap = 4;
      const maxRepairableComponentSize = 6;
      const centerRow = (rows - 1) / 2;
      const centerCol = (cols - 1) / 2;
      const linkDirections = [
        [1, 0],
        [-1, 0],
        [0, 1],
        [0, -1],
      ];
      const repairScoring = {
        recoveryWeight: 260,
        routeAffinityWeight: 210,
        criticalityWeight: 120,
        localityWeight: 65,
        compactnessWeight: 90,
        sizePenaltyPerTile: 6,
      };

      const grid = [];
      const tileElements = new Map();
      const threeTileElements = new Map();
      let routePath = [];
      let pulseTimer = null;
      let pulseRunning = false;
      let currentRate = 0.12;
      let currentLinkRate = 0.06;
      let currentView = "2d";
      let linkDefectCount = 0;
      let unrepairedClusterCount = 0;
      let maxSpareRepairs = 0;
      let lastRepairPlan = [];
      let lastRepairMeta = null;
      let lastPreRepairRouteLength = 0;
      let lastPreRepairRouteExists = false;
      let lastBadClusters = [];
      let reliabilityRuns = 40;
      const links = {
        right: [],
        down: [],
      };

      const svg = document.getElementById("wafer");
      const chipWrap = document.querySelector(".chip-wrap");
      const defectRate = document.getElementById("defectRate");
      const repairBudget = document.getElementById("repairBudget");
      const defectValue = document.getElementById("defectValue");
      const defectLabel = document.getElementById("defectLabel");
      const repairBudgetValue = document.getElementById("repairBudgetValue");
      const repairBudgetLabel = document.getElementById("repairBudgetLabel");
      const linkDefectRate = document.getElementById("linkFaultRate");
      const linkDefectLabel = document.getElementById("linkDefectLabel");
      const linkDefectValue = document.getElementById("linkDefectValue");
      const pulseSpeed = document.getElementById("pulseSpeed");
      const pulseSpeedLabel = document.getElementById("pulseSpeedLabel");
      const pulseSpeedValue = document.getElementById("pulseSpeedValue");
      const pulseLoop = document.getElementById("pulseLoop");
      const allowRepair = document.getElementById("allowRepair");
      const showMesh = document.getElementById("showMesh");
      const showClusters = document.getElementById("showClusters");
      const animateBtn = document.getElementById("animate");
      const runSimulationBtn = document.getElementById("runSimulation");
      const shuffleBtn = document.getElementById("shuffle");
      const status = document.getElementById("status");
      const healthyCount = document.getElementById("healthyCount");
      const repairCount = document.getElementById("repairCount");
      const linkCount = document.getElementById("linkCount");
      const pathLength = document.getElementById("pathLength");
      const utilization = document.getElementById("utilization");
      const remapUtil = document.getElementById("remapUtil");
      const reliabilityRate = document.getElementById("reliabilityRate");
      const reliabilityBars = document.getElementById("reliabilityBars");
      const reliabilitySuccessStat = document.getElementById("reliabilitySuccessStat");
      const reliabilityFailStat = document.getElementById("reliabilityFailStat");
      const reliabilityPathStat = document.getElementById("reliabilityPathStat");
      const view2dBtn = document.getElementById("view2d");
      const view3dBtn = document.getElementById("view3d");
      const canvas3d = document.getElementById("wafer3d");
      const captureModeToggle = document.getElementById("captureMode");
      const autoRotate3dToggle = document.getElementById("autoRotate3d");
      const resetViewBtn = document.getElementById("resetView");
      const tileTooltip = document.getElementById("tileTooltip");

      const start = { r: Math.floor(rows / 2), c: 0 };
      const end = { r: Math.floor(rows / 2), c: cols - 1 };

      const sourceColor = "fill:#b8852f;stroke:#8a5f20;stroke-width:2;";
      const sinkColor = "fill:#9c6b39;stroke:#6e4a14;stroke-width:2;";

      let scene;
      let camera;
      let renderer;
      let tileGroup;
      let packetMesh;
      let tileGeometry;
      let threeInited = false;
      let threeTickActive = false;
      let threeAngleX = 0.62;
      let threeTargetX = 0.62;
      let threeAngleY = -0.84;
      let threeTargetY = -0.84;
      let threeZoom = 1;
      let threeAutoRotate = false;
      let pointerDrag = false;
      let lastPointerX = 0;
      let lastPointerY = 0;
      const rightLinkIndex = (r, c) => r * (cols - 1) + c;
      const downLinkIndex = (r, c) => r * cols + c;

      function key(r, c) {
        return `${r}-${c}`;
      }

      function connectedBadComponents() {
        const visited = new Set();
        const components = [];
        const directions = linkDirections;

        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            const startCell = tileState(r, c);
            if (startCell !== "bad") continue;
            const startKey = key(r, c);
            if (visited.has(startKey)) continue;

            const component = [];
            const queue = [{ r, c }];
            visited.add(startKey);

            while (queue.length > 0) {
              const cur = queue.shift();
              component.push(grid[cur.r * cols + cur.c]);

              for (let i = 0; i < directions.length; i++) {
                const nr = cur.r + directions[i][0];
                const nc = cur.c + directions[i][1];
                if (nr < 0 || nr >= rows || nc < 0 || nc >= cols) continue;
                const k = key(nr, nc);
                if (visited.has(k)) continue;
                if (tileState(nr, nc) !== "bad") continue;
                visited.add(k);
                queue.push({ r: nr, c: nc });
              }
            }

            components.push(component);
          }
        }

        lastBadClusters = components;
        return components;
      }

      function currentBadClusterCount() {
        return lastBadClusters.length;
      }

      function repairMetaDefaults() {
        return {
          used: 0,
          requested: 0,
          selectedComponents: 0,
          skippedByScore: 0,
          skippedByBudget: 0,
          budgetExhausted: false,
          available: maxSpareRepairs,
        };
      }

      function isIO(r, c) {
        return c === 0 || c === cols - 1;
      }

      function tileState(r, c) {
        const t = grid[r * cols + c];
        return t ? t.state : "bad";
      }

      function walkable(t) {
        return t === "good" || t === "repair" || t === "io";
      }

      function linkHealth(r, c, nr, nc) {
        if (nr === r && nc === c + 1) {
          return links.right[rightLinkIndex(r, c)] === "good";
        }
        if (nr === r && nc === c - 1) {
          return links.right[rightLinkIndex(r, c - 1)] === "good";
        }
        if (nr === r + 1 && nc === c) {
          return links.down[downLinkIndex(r, c)] === "good";
        }
        if (nr === r - 1 && nc === c) {
          return links.down[downLinkIndex(r - 1, c)] === "good";
        }
        return false;
      }

      function countBadLinks() {
        let c = 0;
        for (let i = 0; i < links.right.length; i++) {
          if (links.right[i] === "bad") c++;
        }
        for (let i = 0; i < links.down.length; i++) {
          if (links.down[i] === "bad") c++;
        }
        return c;
      }

      function tileCriticality(r, c, startDist, endDist, shortestEdges) {
        const locality = tileLocalityScore(r, c);
        if (!startDist || !endDist || shortestEdges < 0) return locality;
        return locality * 0.35 + tileFlowCriticality(r, c, startDist, endDist, shortestEdges) * 0.65;
      }

      function tileLocalityScore(r, c) {
        const rowAffinity = 1 / (1 + Math.abs(r - centerRow) * 0.45);
        const ioAffinity = 1 / (1 + Math.abs(c - centerCol) * 0.05);
        const edgeAffinity = 1 / (1 + Math.min(c, cols - 1 - c) * 0.2);
        return rowAffinity * 0.65 + ioAffinity * 0.2 + edgeAffinity * 0.15;
      }

      function tileFlowCriticality(r, c, startDist, endDist, shortestEdges) {
        if (shortestEdges < 0) return 0;
        const ds = startDist[r][c];
        const de = endDist[r][c];
        if (ds < 0 || de < 0) return 0;
        const detour = ds + de - shortestEdges;
        return 1 / (1 + detour * detour);
      }

      function reconstructPathFromPrev(prev, dist, sourcePoint = start, target = end) {
        if (dist[target.r][target.c] < 0) return [];
        const path = [];
        let cur = { r: target.r, c: target.c };
        while (cur) {
          path.push(cur);
          if (cur.r === sourcePoint.r && cur.c === sourcePoint.c) break;
          const next = prev[cur.r][cur.c];
          if (!next) break;
          cur = next;
        }
        return path.reverse();
      }

      function routeAffinityForComponent(component, routeSet) {
        if (!routeSet || routeSet.size === 0) return 0;

        let score = 0;
        for (let i = 0; i < component.length; i++) {
          const tile = component[i];
          const here = key(tile.r, tile.c);
          let local = 0;

          if (routeSet.has(here)) {
            local = 1;
          } else {
            for (let d = 0; d < linkDirections.length; d++) {
              const nr = tile.r + linkDirections[d][0];
              const nc = tile.c + linkDirections[d][1];
              if (nr < 0 || nr >= rows || nc < 0 || nc >= cols) continue;
              if (routeSet.has(key(nr, nc))) {
                local = 0.55;
                break;
              }
            }
          }

          if (local === 0) {
            for (let dr = -2; dr <= 2; dr++) {
              let nearby = false;
              for (let dc = -2; dc <= 2; dc++) {
                if (Math.abs(dr) + Math.abs(dc) > 2) continue;
                const rr = tile.r + dr;
                const cc = tile.c + dc;
                if (rr < 0 || rr >= rows || cc < 0 || cc >= cols) continue;
                if (routeSet.has(key(rr, cc))) {
                  nearby = true;
                  break;
                }
              }
              if (nearby) {
                local = 0.12;
                break;
              }
            }
          }

          score += local;
        }

        return score / component.length;
      }

      function routeDistanceMap(repairedSet = null, sourcePoint = start) {
        const dist = Array.from({ length: rows }, () => Array(cols).fill(-1));
        const prev = Array.from({ length: rows }, () => Array(cols).fill(null));

        if (!walkable(tileStateForRoute(sourcePoint.r, sourcePoint.c, repairedSet))) {
          return { dist, prev };
        }

        const queue = [{ ...sourcePoint }];
        dist[sourcePoint.r][sourcePoint.c] = 0;
        let qi = 0;

        while (qi < queue.length) {
          const cur = queue[qi++];
          for (let i = 0; i < linkDirections.length; i++) {
            const nr = cur.r + linkDirections[i][0];
            const nc = cur.c + linkDirections[i][1];
            if (nr < 0 || nr >= rows || nc < 0 || nc >= cols) continue;
            if (dist[nr][nc] !== -1) continue;
            if (!linkHealth(cur.r, cur.c, nr, nc)) continue;
            const ns = tileStateForRoute(nr, nc, repairedSet);
            if (!walkable(ns)) continue;
            dist[nr][nc] = dist[cur.r][cur.c] + 1;
            prev[nr][nc] = { r: cur.r, c: cur.c };
            queue.push({ r: nr, c: nc });
          }
        }

        return { dist, prev };
      }

      function shortestRouteLength(repairedSet = null) {
        const { dist } = routeDistanceMap(repairedSet);
        const endDist = dist[end.r][end.c];
        return endDist >= 0 ? endDist + 1 : 0;
      }

      function componentCompactness(component) {
        let minR = rows;
        let maxR = 0;
        let minC = cols;
        let maxC = 0;

        for (let i = 0; i < component.length; i++) {
          const tile = component[i];
          minR = Math.min(minR, tile.r);
          maxR = Math.max(maxR, tile.r);
          minC = Math.min(minC, tile.c);
          maxC = Math.max(maxC, tile.c);
        }

        return 1 / (1 + (maxR - minR) + (maxC - minC));
      }

      function buildRepairPlan(enabled = true) {
        if (!enabled || !allowRepair.checked) return { plan: [], meta: repairMetaDefaults() };

        const baseRouteResult = routeDistanceMap();
        const fromStart = baseRouteResult.dist;
        const fromEnd = routeDistanceMap(null, end).dist;
        const baseRoutePath = reconstructPathFromPrev(baseRouteResult.prev, fromStart);
        const baseRouteSet = new Set(baseRoutePath.map((tile) => key(tile.r, tile.c)));
        const shortestEdges = fromStart[end.r][end.c];
        const shortestLen = shortestEdges >= 0 ? shortestEdges + 1 : 0;

        const components = connectedBadComponents().filter((component) => {
          return component.length <= maxRepairableComponentSize;
        });

        const candidates = [];
        for (let i = 0; i < components.length; i++) {
          const component = components[i];
          const componentSet = new Set(component.map((t) => key(t.r, t.c)));
          const repairedLen = shortestRouteLength(componentSet);
          const recoveryGain = shortestLen > 0
            ? repairedLen > 0
              ? (shortestLen - repairedLen) / shortestLen
              : -1
            : repairedLen > 0
            ? 0.7
            : -1;

          let criticalityScore = 0;
          for (let j = 0; j < component.length; j++) {
            const t = component[j];
            criticalityScore += tileCriticality(t.r, t.c, fromStart, fromEnd, shortestEdges);
          }
          criticalityScore /= component.length;
          const routeAffinity = routeAffinityForComponent(component, baseRouteSet);
          let localityScore = 0;
          for (let j = 0; j < component.length; j++) {
            localityScore += tileLocalityScore(component[j].r, component[j].c);
          }
          localityScore /= component.length;
          const compactness = componentCompactness(component);
          const score = (
            repairScoring.recoveryWeight * recoveryGain
            + repairScoring.routeAffinityWeight * routeAffinity
            + repairScoring.criticalityWeight * criticalityScore
            + repairScoring.localityWeight * localityScore
            + repairScoring.compactnessWeight * compactness
          ) - (repairScoring.sizePenaltyPerTile * component.length);
          candidates.push({ component, score });
        }

        candidates.sort((a, b) => b.score - a.score);

        const repairPool = Math.min(maxSpareRepairs, rows * cols);
        let remaining = repairPool;
        const selected = [];
        let skippedByScore = 0;
        let skippedByBudget = 0;
        let requested = 0;
        const meta = repairMetaDefaults();
        meta.available = repairPool;

        for (let i = 0; i < candidates.length && remaining > 0; i++) {
          const candidate = candidates[i];
          requested += candidate.component.length;
          if (candidate.score < 8) {
            skippedByScore += candidate.component.length;
            continue;
          }
          if (candidate.component.length > remaining) {
            skippedByBudget += candidate.component.length;
            continue;
          }

          for (let j = 0; j < candidate.component.length; j++) {
            selected.push(candidate.component[j]);
          }
          remaining -= candidate.component.length;
        }

        meta.used = repairPool - remaining;
        meta.requested = requested;
        meta.selectedComponents = selected.length;
        meta.skippedByScore = skippedByScore;
        meta.skippedByBudget = skippedByBudget;
        meta.budgetExhausted = remaining === 0 && selected.length < candidates.length;
        return { plan: selected, meta };
      }

      function applyRepairPlan(plan) {
        for (let i = 0; i < plan.length; i++) {
          const tile = plan[i];
          tile.state = "repair";
        }
      }

      function tileStateForRoute(r, c, repairedSet = null) {
        const tileKey = key(r, c);
        if (repairedSet && repairedSet.has(tileKey)) {
          return "repair";
        }
        return tileState(r, c);
      }

      function findRoute(repairedSet = null) {
        const result = routeDistanceMap(repairedSet);
        const dist = result.dist;
        const prev = result.prev;

        if (dist[end.r][end.c] === -1) {
          return [];
        }

        const path = [];
        let cur = { r: end.r, c: end.c };
        while (cur) {
          path.push(cur);
          cur = prev[cur.r][cur.c];
        }
        return path.reverse();
      }

      function routePacket() {
        routePath = findRoute();
        return routePath;
      }

      function tileColor3D(state, c) {
        if (state === "bad") return 0x8c2f36;
        if (state === "repair") return 0x5d9348;
        if (state === "io") return c === 0 ? 0xb8852f : 0x9c6b39;
        return 0xd7b16a;
      }

      function worldForTile(r, c) {
        const spacing = 1.1;
        const x = c * spacing - ((cols - 1) * spacing) / 2;
        const z = r * spacing - ((rows - 1) * spacing) / 2;
        return { x, z };
      }

      function initThree() {
        if (threeInited) return true;
        if (typeof THREE === "undefined") {
          status.textContent = "Three.js not available. Continue with 2D mode.";
          return false;
        }

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x292018);
        camera = new THREE.PerspectiveCamera(45, 1, 0.1, 5000);

        renderer = new THREE.WebGLRenderer({ canvas: canvas3d, antialias: true });
        renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
        camera.position.set(24, 20, 24);
        camera.up.set(0, 1, 0);

        const ambient = new THREE.AmbientLight(0xffffff, 0.7);
        const keyLight = new THREE.DirectionalLight(0xffffff, 0.9);
        const fillLight = new THREE.DirectionalLight(0xceb176, 0.7);
        keyLight.position.set(12, 16, 8);
        fillLight.position.set(-10, 12, -8);
        scene.add(ambient, keyLight, fillLight);

        tileGroup = new THREE.Group();
        tileGroup.rotation.x = -Math.PI / 2.5;
        scene.add(tileGroup);

        tileGeometry = new THREE.BoxGeometry(0.9, 0.3, 0.9);
        const packetGeometry = new THREE.SphereGeometry(0.25, 16, 12);
        const packetMaterial = new THREE.MeshStandardMaterial({
          color: 0xf6e6be,
          emissive: 0x8c6a26,
        });
        packetMesh = new THREE.Mesh(packetGeometry, packetMaterial);
        packetMesh.visible = false;
        tileGroup.add(packetMesh);

        canvas3d.style.touchAction = "none";
        canvas3d.addEventListener("pointerdown", (event) => {
          pointerDrag = true;
          lastPointerX = event.clientX;
          lastPointerY = event.clientY;
        });

        canvas3d.addEventListener("pointermove", (event) => {
          if (!pointerDrag) return;
          const dx = event.clientX - lastPointerX;
          const dy = event.clientY - lastPointerY;
          threeTargetY += dx * 0.005;
          threeTargetX -= dy * 0.005;
          threeTargetX = Math.min(Math.max(threeTargetX, -1.2), 1.0);
          lastPointerX = event.clientX;
          lastPointerY = event.clientY;
        });

        window.addEventListener("pointerup", () => {
          pointerDrag = false;
        });

        canvas3d.addEventListener("wheel", (event) => {
          event.preventDefault();
          if (event.deltaY > 0) {
            threeZoom = Math.min(1.8, threeZoom + 0.06);
          } else {
            threeZoom = Math.max(0.6, threeZoom - 0.06);
          }
        }, { passive: false });

        threeInited = true;
        resizeThree();
        if (!threeTickActive) {
          animateThree();
          threeTickActive = true;
        }
        return true;
      }

      function animateThree() {
        requestAnimationFrame(animateThree);
        if (!renderer || !camera || !scene) return;

        if (threeAutoRotate && !pointerDrag) {
          threeTargetY += 0.003;
        }

        threeAngleX += (threeTargetX - threeAngleX) * 0.1;
        threeAngleY += (threeTargetY - threeAngleY) * 0.1;

        const radius = Math.max(rows, cols) * 1.5 * threeZoom;
        const x = Math.cos(threeAngleY) * Math.cos(threeAngleX) * radius;
        const y = Math.sin(threeAngleX) * radius + 7;
        const z = Math.sin(threeAngleY) * Math.cos(threeAngleX) * radius;
        camera.position.set(x, y, z);
        camera.lookAt(0, 0, 0);
        renderer.render(scene, camera);
      }

      function resizeThree() {
        if (!renderer || !camera || !canvas3d || !chipWrap) return;
        const width = Math.max(300, Math.floor(chipWrap.clientWidth));
        const height = Math.max(300, Math.floor(chipWrap.clientHeight));
        renderer.setSize(width, height, false);
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
      }

      function rebuildThreeGrid() {
        if (!threeInited || !tileGroup) return;

        while (tileGroup.children.length > 0) {
          tileGroup.remove(tileGroup.children[0]);
        }
        threeTileElements.clear();

        if (!tileGeometry) {
          tileGeometry = new THREE.BoxGeometry(0.9, 0.3, 0.9);
        }

        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            const tile = grid[r * cols + c];
            const color = tileColor3D(tile.state, c);
            const material = new THREE.MeshStandardMaterial({
              color,
              roughness: 0.45,
              metalness: 0.05,
            });
            const mesh = new THREE.Mesh(tileGeometry, material);
            const pos = worldForTile(r, c);
            mesh.position.set(pos.x, 0, pos.z);
            mesh.userData = {
              key: key(r, c),
              r,
              c,
            };
            tileGroup.add(mesh);
            threeTileElements.set(key(r, c), mesh);
          }
        }

        tileGroup.add(packetMesh);
        paint3DTiles();
      }

      function paint3DTiles() {
        const routeSet = new Set();
        for (let i = 0; i < routePath.length; i++) {
          routeSet.add(key(routePath[i].r, routePath[i].c));
        }

        for (const tile of grid) {
          const tileKey = key(tile.r, tile.c);
          const mesh = threeTileElements.get(tileKey);
          if (!mesh) continue;

          const base = tileColor3D(tile.state, tile.c);
          mesh.material.color.setHex(base);
          if (routeSet.has(tileKey) && routePath.length > 1) {
            mesh.material.emissive.setHex(0xbf8f2a);
            mesh.material.emissiveIntensity = 0.45;
          } else {
            mesh.material.emissive.setHex(0x000000);
            mesh.material.emissiveIntensity = 0;
          }
        }

        if (routePath.length === 0 && packetMesh) {
          packetMesh.visible = false;
        }
      }

      function createLayout() {
        const contentW = cols * tileSize + (cols - 1) * gap + 40;
        const contentH = rows * tileSize + (rows - 1) * gap + 40;
        svg.setAttribute("viewBox", `0 0 ${contentW} ${contentH}`);

        while (svg.firstChild) {
          svg.removeChild(svg.firstChild);
        }

        const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
        const marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
        marker.setAttribute("id", "arr");
        marker.setAttribute("markerWidth", "9");
        marker.setAttribute("markerHeight", "9");
        marker.setAttribute("refX", "8");
        marker.setAttribute("refY", "4.5");
        marker.setAttribute("orient", "auto");
        const mPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
        mPath.setAttribute("d", "M0,0 L9,4.5 L0,9 Z");
        mPath.setAttribute("fill", "#4d3920");
        marker.appendChild(mPath);
        defs.appendChild(marker);
        svg.appendChild(defs);

        const frame = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        frame.setAttribute("x", 8);
        frame.setAttribute("y", 8);
        frame.setAttribute("width", contentW - 16);
        frame.setAttribute("height", contentH - 16);
        frame.setAttribute("rx", 12);
        frame.setAttribute("fill", "#fbf3de");
        frame.setAttribute("stroke", "#e4cf9f");
        frame.setAttribute("stroke-width", 1.5);
        svg.appendChild(frame);

        const meshGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
        meshGroup.setAttribute("id", "mesh");
        meshGroup.setAttribute("opacity", "0.55");
        svg.appendChild(meshGroup);

        const clusterOutlinesGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
        clusterOutlinesGroup.setAttribute("id", "clusterOutlines");
        svg.appendChild(clusterOutlinesGroup);

        const tilesGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
        tilesGroup.setAttribute("id", "tiles");
        svg.appendChild(tilesGroup);

        const pathGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
        pathGroup.setAttribute("id", "path");
        pathGroup.setAttribute("fill", "none");
        pathGroup.setAttribute("stroke", "#f6cc57");
        pathGroup.setAttribute("stroke-width", 4);
        pathGroup.setAttribute("stroke-linecap", "round");
        pathGroup.setAttribute("marker-end", "url(#arr)");
        pathGroup.style.opacity = 0.9;
        svg.appendChild(pathGroup);

        tileElements.clear();

        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            const state = grid[r * cols + c].state;
            const x = 20 + c * (tileSize + gap);
            const y = 20 + r * (tileSize + gap);

            const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            rect.setAttribute("x", x);
            rect.setAttribute("y", y);
            rect.setAttribute("width", tileSize);
            rect.setAttribute("height", tileSize);
            rect.setAttribute("rx", 5);
            rect.setAttribute("data-r", r);
            rect.setAttribute("data-c", c);
            rect.setAttribute("data-state", state);

            if (state === "io") {
              rect.setAttribute("fill", "#b8852f");
              if (c === 0) rect.setAttribute("style", sourceColor);
              else if (c === cols - 1) rect.setAttribute("style", sinkColor);
            } else if (state === "good") {
              rect.setAttribute("fill", "#d7b16a");
            } else if (state === "repair") {
              rect.setAttribute("fill", "#5d9348");
            } else {
              rect.setAttribute("fill", "#8c2f36");
            }

            rect.setAttribute("stroke", "#e8d7b2");
            rect.setAttribute("stroke-width", 1);
            rect.setAttribute("class", `cell ${state}`);
            rect.addEventListener("pointerenter", showTileTooltip);
            rect.addEventListener("pointermove", showTileTooltip);
            rect.addEventListener("pointerleave", hideTileTooltip);
            const title = document.createElementNS("http://www.w3.org/2000/svg", "title");
            title.textContent = `Tile (${r}, ${c}) · state=${state} · route=${routePath.some((p) => p.r === r && p.c === c) ? "active" : "inactive"}`;
            rect.appendChild(title);

            tilesGroup.appendChild(rect);
            tileElements.set(key(r, c), rect);
          }
        }
      }

      function randomizeGrid({
        includeRepair = allowRepair.checked,
      } = {}) {
        grid.length = 0;
        const failRate = Number(defectRate.value);
        const failLinkRate = Number(linkDefectRate.value);
        maxSpareRepairs = Math.floor(rows * cols * (Number(repairBudget.value) / 100));
        currentRate = failRate;
        currentLinkRate = failLinkRate;

        links.right.length = 0;
        links.down.length = 0;

        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            let state = "good";
            if (isIO(r, c)) {
              state = "io";
            } else {
              const p = Math.random();
              if (p < failRate) state = "bad";
            }
            grid.push({ r, c, state });
          }
        }

        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols - 1; c++) {
            links.right.push(Math.random() < failLinkRate ? "bad" : "good");
          }
        }

        for (let r = 0; r < rows - 1; r++) {
          for (let c = 0; c < cols; c++) {
            links.down.push(Math.random() < failLinkRate ? "bad" : "good");
          }
        }

        const baseRoute = routeDistanceMap();
        const baseRoutePath = reconstructPathFromPrev(baseRoute.prev, baseRoute.dist);
        lastPreRepairRouteExists = baseRoute.dist[end.r][end.c] >= 0;
        lastPreRepairRouteLength = lastPreRepairRouteExists ? baseRoutePath.length : 0;
        const repairResult = includeRepair ? buildRepairPlan(true) : { plan: [], meta: repairMetaDefaults() };
        lastRepairPlan = repairResult.plan || [];
        lastRepairMeta = repairResult.meta || repairMetaDefaults();

        if (includeRepair) {
          applyRepairPlan(lastRepairPlan);
        }

        connectedBadComponents();
        linkDefectCount = countBadLinks();
        unrepairedClusterCount = currentBadClusterCount();
      }

      function drawClusterOutlines() {
        const outlines = document.getElementById("clusterOutlines");
        if (!outlines) return;
        while (outlines.firstChild) {
          outlines.removeChild(outlines.firstChild);
        }
        if (!showClusters || !showClusters.checked || !lastBadClusters.length) return;

        for (let ci = 0; ci < lastBadClusters.length; ci++) {
          const component = lastBadClusters[ci];
          if (!component || component.length === 0) continue;

          let minR = rows;
          let maxR = 0;
          let minC = cols;
          let maxC = 0;
          for (let i = 0; i < component.length; i++) {
            const tile = component[i];
            minR = Math.min(minR, tile.r);
            maxR = Math.max(maxR, tile.r);
            minC = Math.min(minC, tile.c);
            maxC = Math.max(maxC, tile.c);
          }

          const x = 20 + minC * (tileSize + gap) - 1;
          const y = 20 + minR * (tileSize + gap) - 1;
          const w = (maxC - minC + 1) * tileSize + (maxC - minC) * gap + 2;
          const h = (maxR - minR + 1) * tileSize + (maxR - minR) * gap + 2;
          const stroke = component.length > maxRepairableComponentSize ? "#8c2f36" : "#6e2a2a";

          const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
          rect.setAttribute("x", x);
          rect.setAttribute("y", y);
          rect.setAttribute("width", w);
          rect.setAttribute("height", h);
          rect.setAttribute("rx", 6);
          rect.setAttribute("stroke", stroke);
          rect.setAttribute("class", "cluster-outline");
          outlines.appendChild(rect);

          if (component.length > 1) {
            const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
            label.setAttribute("x", x + w / 2);
            label.setAttribute("y", y + h / 2 + 4);
            label.setAttribute("class", "cluster-label");
            label.textContent = `C${ci + 1} (${component.length})`;
            outlines.appendChild(label);
          }
        }
      }

      function drawMesh(show = true) {
        const meshGroup = document.getElementById("mesh");
        while (meshGroup.firstChild) {
          meshGroup.removeChild(meshGroup.firstChild);
        }
        if (!show) return;

        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            const from = tileState(r, c);
            const toRightWalkable = c + 1 < cols ? tileState(r, c + 1) : "bad";
            const rightHealthy = c + 1 < cols ? links.right[rightLinkIndex(r, c)] === "good" : false;
            const x = 20 + c * (tileSize + gap) + tileSize / 2;
            const y = 20 + r * (tileSize + gap) + tileSize / 2;

            if (c + 1 < cols && walkable(from) && walkable(toRightWalkable)) {
              const x2 = 20 + (c + 1) * (tileSize + gap) + tileSize / 2;
              const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
              line.setAttribute("x1", x);
              line.setAttribute("y1", y);
              line.setAttribute("x2", x2);
              line.setAttribute("y2", y);
              if (rightHealthy) {
                line.setAttribute("stroke", "var(--mesh)");
              } else {
                line.setAttribute("stroke", "#8c2f36");
                line.setAttribute("stroke-dasharray", "4 4");
              }
              line.setAttribute("stroke-width", 1.6);
              meshGroup.appendChild(line);
            }

            if (r + 1 < rows) {
              const toDownWalkable = tileState(r + 1, c);
              const downHealthy = links.down[downLinkIndex(r, c)] === "good";
              if (!walkable(from) || !walkable(toDownWalkable)) continue;
              const y2 = 20 + (r + 1) * (tileSize + gap) + tileSize / 2;
              const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
              line.setAttribute("x1", x);
              line.setAttribute("y1", y);
              line.setAttribute("x2", x);
              line.setAttribute("y2", y2);
              if (downHealthy) {
                line.setAttribute("stroke", "var(--mesh)");
              } else {
                line.setAttribute("stroke", "#8c2f36");
                line.setAttribute("stroke-dasharray", "4 4");
              }
              line.setAttribute("stroke-width", 1.6);
              meshGroup.appendChild(line);
            }
          }
        }
      }

      
      function cloneGridState() {
        return {
          grid: grid.map((tile) => ({ r: tile.r, c: tile.c, state: tile.state })),
          right: links.right.slice(),
          down: links.down.slice(),
          repairPlan: lastRepairPlan.map((tile) => ({ r: tile.r, c: tile.c })),
          repairMeta: lastRepairMeta ? { ...lastRepairMeta } : repairMetaDefaults(),
          preRouteExists: lastPreRepairRouteExists,
          preRouteLength: lastPreRepairRouteLength,
          rate: currentRate,
          linkRate: currentLinkRate,
        };
      }

      function restoreGridState(snapshot) {
        grid.length = 0;
        for (let i = 0; i < snapshot.grid.length; i++) {
          const tile = snapshot.grid[i];
          grid.push({ r: tile.r, c: tile.c, state: tile.state });
        }
        links.right = snapshot.right.slice();
        links.down = snapshot.down.slice();
        currentRate = snapshot.rate;
        currentLinkRate = snapshot.linkRate;
        maxSpareRepairs = Math.floor(rows * cols * (Number(repairBudget.value) / 100));
        linkDefectCount = countBadLinks();
        connectedBadComponents();
        unrepairedClusterCount = currentBadClusterCount();
        lastRepairPlan = (snapshot.repairPlan || []).map((tile) => grid[tile.r * cols + tile.c]).filter(Boolean);
        lastRepairMeta = snapshot.repairMeta ? { ...snapshot.repairMeta } : repairMetaDefaults();
        lastPreRepairRouteLength = snapshot.preRouteLength || 0;
        lastPreRepairRouteExists = snapshot.preRouteExists || false;
      }

      function paintTiles() {
        let bad = 0;
        let repair = 0;
        let healthy = 0;
        const total = rows * cols;

        for (const tile of grid) {
          const k = key(tile.r, tile.c);
          const el = tileElements.get(k);
          if (!el) continue;
          el.classList.remove("path", "flow");

          if (tile.state === "bad") {
            bad++;
          } else {
            if (tile.state === "repair") {
              repair++;
            } else {
              healthy++;
            }
            if (tile.state === "io") {
              el.setAttribute("fill", tile.c === 0 ? "#b8852f" : "#9c6b39");
            } else if (tile.state === "repair") {
              el.setAttribute("fill", "var(--repair)");
            } else {
              el.setAttribute("fill", "var(--good-soft)");
            }
          }
        }

        const usable = total - bad;
        healthyCount.textContent = `${usable} / ${total}`;
        repairCount.textContent = repair.toString();
        linkCount.textContent = `${linkDefectCount}`;
        const ratio = Math.round((usable / total) * 100);
        utilization.textContent = `${ratio}%`;

        routePacket();

        const pathEdges = document.getElementById("path");
        while (pathEdges.firstChild) {
          pathEdges.removeChild(pathEdges.firstChild);
        }

        if (routePath.length > 1) {
          const baseRouteText = lastPreRepairRouteExists
            ? `Raw path baseline length: ${lastPreRepairRouteLength || "n/a"} tiles.`
            : "Raw path was blocked before remap.";
          const remapText = allowRepair.checked ? `Remap used: ${lastRepairPlan.length} tiles.` : "Remap disabled.";
          const clusterText = unrepairedClusterCount > 0
            ? `${unrepairedClusterCount} defect clusters still unrepaired.`
            : "No unrepaired defect clusters remain.";
          const linkText = linkDefectCount > 0
            ? `${linkDefectCount} bad links remain.`
            : "No bad links remain.";
          for (let i = 0; i < routePath.length - 1; i++) {
            const a = routePath[i];
            const b = routePath[i + 1];
            const ax = 20 + a.c * (tileSize + gap) + tileSize / 2;
            const ay = 20 + a.r * (tileSize + gap) + tileSize / 2;
            const bx = 20 + b.c * (tileSize + gap) + tileSize / 2;
            const by = 20 + b.r * (tileSize + gap) + tileSize / 2;
            const ln = document.createElementNS("http://www.w3.org/2000/svg", "line");
            ln.setAttribute("x1", ax);
            ln.setAttribute("y1", ay);
            ln.setAttribute("x2", bx);
            ln.setAttribute("y2", by);
            ln.setAttribute("class", "route-segment");
            pathEdges.appendChild(ln);
          }
          pathLength.textContent = `${routePath.length}`;
          const remapOutcome = allowRepair.checked
            ? lastPreRepairRouteExists
              ? "Path exists in baseline; remap may still improve robustness."
              : "Raw map was blocked. Remap created an alternate feasible route."
            : "Remap disabled. Route uses existing healthy links/tiles.";
          status.textContent = `Route found. ${remapOutcome} ${baseRouteText} ${remapText} ${clusterText} ${linkText}`.trim();
        } else {
          pathLength.textContent = "blocked";
          const reasons = [];
          if (!lastPreRepairRouteExists) {
            reasons.push("No route in the raw fault map.");
          }
          if (allowRepair.checked && lastRepairMeta) {
            if (lastRepairMeta.budgetExhausted && maxSpareRepairs > 0) {
              reasons.push(`Remap budget exhausted at ${lastRepairPlan.length}/${maxSpareRepairs} tiles.`);
            }
            if (linkDefectCount > 0) reasons.push(`${linkDefectCount} faulty links remain.`);
            if (unrepairedClusterCount > 0) reasons.push(`${unrepairedClusterCount} unrepaired defect clusters remain.`);
            if (lastRepairMeta.skippedByScore > 0 && !lastRepairMeta.budgetExhausted) {
              reasons.push("Low-priority clusters were skipped to preserve repair budget.");
            }
          } else if (!allowRepair.checked) {
            reasons.push("Enable remap for spare-tile recovery behavior.");
          }
          if (reasons.length === 0) {
            reasons.push(`No route found with current configuration.`);
          }
          status.textContent = `No valid route from input to output. ${reasons.join(" ")}`;
        }
        const remapPct = maxSpareRepairs > 0 ? Math.round((lastRepairPlan.length / maxSpareRepairs) * 100) : 0;
        remapUtil.textContent = `${remapPct}% (${lastRepairPlan.length}/${maxSpareRepairs})`;
        drawClusterOutlines();

        if (threeInited) paint3DTiles();
      }

      function setPacketPosition(stepIndex) {
        if (!packetMesh || routePath.length === 0) return;
        const p = routePath[stepIndex];
        if (!p) {
          packetMesh.visible = false;
          return;
        }
        const pos = worldForTile(p.r, p.c);
        packetMesh.position.set(pos.x, 0.5, pos.z);
        packetMesh.visible = true;
      }

      function setCaptureMode(enabled) {
        document.body.classList.toggle("capture-mode", enabled);
      }

      function hideTileTooltip() {
        if (tileTooltip) {
          tileTooltip.style.display = "none";
        }
      }

      function showTileTooltip(event) {
        if (!tileTooltip || currentView !== "2d") return;

        const el = event.currentTarget;
        if (!el) return;

        const r = Number(el.dataset.r);
        const c = Number(el.dataset.c);
        const state = el.dataset.state || tileState(r, c);
        const isIOCell = isIO(r, c);

        const routeSet = new Set();
        for (let i = 0; i < routePath.length; i++) {
          routeSet.add(key(routePath[i].r, routePath[i].c));
        }
        const inPath = routeSet.has(key(r, c));

        const clusterText = isBadTileByState(state)
          ? "in defect set"
          : tileState(r, c) === "repair"
            ? "remapped"
            : isIOCell
              ? "I/O boundary"
              : "healthy";

        const rightHealth = c + 1 < cols ? linkHealth(r, c, r, c + 1) : false;
        const leftHealth = c - 1 >= 0 ? linkHealth(r, c, r, c - 1) : false;
        const downHealth = r + 1 < rows ? linkHealth(r, c, r + 1, c) : false;
        const upHealth = r - 1 >= 0 ? linkHealth(r, c, r - 1, c) : false;
        const goodLinks = Number(rightHealth) + Number(leftHealth) + Number(downHealth) + Number(upHealth);

        tileTooltip.innerHTML = `
          <strong>Tile ${r},${c}</strong><br/>
          State: ${state}<br/>
          Route: ${inPath ? "active" : "inactive"}<br/>
          Link health: ${goodLinks}/4<br/>
          ${clusterText}
        `;

        const bounds = chipWrap.getBoundingClientRect();
        tileTooltip.style.display = "block";
        tileTooltip.style.left = `${Math.min(
          bounds.width - 180,
          Math.max(0, event.clientX - bounds.left + 10),
        )}px`;
        tileTooltip.style.top = `${Math.max(0, event.clientY - bounds.top - 28)}px`;
      }

      function isBadTileByState(state) {
        return state === "bad";
      }

      function resetThreeView() {
        threeTargetX = 0.62;
        threeTargetY = -0.84;
        threeAngleX = 0.62;
        threeAngleY = -0.84;
        threeZoom = 1;
        if (threeInited) {
          paint3DTiles();
        }
      }

      function clearPulse() {
        hideTileTooltip();
        if (pulseTimer) {
          clearTimeout(pulseTimer);
          pulseTimer = null;
        }
        pulseRunning = false;
        animateBtn.textContent = "Pulse one packet path";
        routePath.forEach((p) => {
          const el = tileElements.get(key(p.r, p.c));
          if (el) el.classList.remove("path", "flow");
        });

        if (packetMesh) {
          packetMesh.visible = false;
        }
        if (threeInited) paint3DTiles();
      }

      function clearReliabilityFrame() {
        if (!reliabilityBars) return;
        reliabilityBars.textContent = "";
        reliabilitySuccessStat.textContent = "Success: —";
        reliabilityFailStat.textContent = "Fail: —";
        reliabilityPathStat.textContent = "Avg route: —";
      }

      function renderReliabilityBars(results) {
        if (!reliabilityBars) return;
        reliabilityBars.textContent = "";

        if (!results || results.length === 0) {
          const empty = document.createElement("div");
          empty.textContent = "No runs completed.";
          empty.style.color = "#6f5431";
          empty.style.fontSize = "12px";
          reliabilityBars.appendChild(empty);
          return;
        }

        const successes = results.filter((result) => result.success).length;
        const failures = results.length - successes;
        const validPaths = results.filter((result) => result.pathLength > 0).map((result) => result.pathLength);
        const maxPath = Math.max(1, ...validPaths, 1);
        const avgPath = validPaths.length > 0
          ? (validPaths.reduce((sum, value) => sum + value, 0) / validPaths.length).toFixed(1)
          : "—";

        reliabilitySuccessStat.textContent = `Success: ${successes}/${results.length}`;
        reliabilityFailStat.textContent = `Fail: ${failures}/${results.length}`;
        reliabilityPathStat.textContent = `Avg route: ${avgPath}`;

        for (let i = 0; i < results.length; i++) {
          const result = results[i];
          const bar = document.createElement("span");
          bar.className = `result-bar ${result.success ? "success" : "fail"}`;
          const pathValue = result.success ? result.pathLength : 1;
          const height = Math.max(6, Math.round((pathValue / maxPath) * 66));
          bar.style.height = `${height}px`;
          const repairedText = allowRepair.checked ? `, repair tiles ${result.repairCount}` : "";
          bar.title = `Run ${i + 1}: ${result.success ? "routed" : "blocked"} | path ${result.pathLength || 0}${repairedText} | bad ${result.badTiles} tiles, ${result.badLinks} links`;
          reliabilityBars.appendChild(bar);
        }
      }

      function runYieldSimulation() {
        status.textContent = `Running reliability simulation (${reliabilityRuns} maps)...`;
        runSimulationBtn.disabled = true;
        clearPulse();
        clearReliabilityFrame();

        const snapshot = cloneGridState();
        let routed = 0;
        let totalPath = 0;
        let totalRepairs = 0;
        let totalBad = 0;
        let totalLinks = 0;
        const runResults = [];

        for (let i = 0; i < reliabilityRuns; i++) {
          randomizeGrid({ includeRepair: allowRepair.checked });
          routePacket();

          const isRouted = routePath.length > 1;
          const badCount = grid.filter((tile) => tile.state === "bad").length;
          const badLinks = linkDefectCount;
          const repairCount = allowRepair.checked ? lastRepairPlan.length : 0;

          runResults.push({
            success: isRouted,
            pathLength: routePath.length,
            badTiles: badCount,
            badLinks,
            repairCount,
          });

          if (isRouted) {
            routed++;
            totalPath += routePath.length;
          }

          totalBad += badCount;
          totalLinks += badLinks;
          if (allowRepair.checked) {
            totalRepairs += repairCount;
          }
        }

        restoreGridState(snapshot);
        createLayout();
        drawMesh(showMesh.checked);
        paintTiles();
        renderReliabilityBars(runResults);

        const routedRate = Math.round((routed / reliabilityRuns) * 1000) / 10;
        const avgPath = routed > 0 ? Math.round((totalPath / routed) * 10) / 10 : 0;
        const avgBad = Math.round(totalBad / reliabilityRuns);
        const avgLinks = Math.round(totalLinks / reliabilityRuns);
        const avgRepairs = routed > 0 ? Math.round((totalRepairs / routed) * 10) / 10 : 0;

        reliabilityRate.textContent = `${routedRate}% (${routed}/${reliabilityRuns})`;
        const summary = `${routedRate}% with ${routed} routes over ${reliabilityRuns} maps`;
        status.textContent = `Reliability simulation complete: ${summary}. Avg route ${avgPath}, avg bad tiles ${avgBad}, avg bad links ${avgLinks}.${allowRepair.checked ? ` Avg remap usage ${avgRepairs}/${maxSpareRepairs}.` : ""}`;

        runSimulationBtn.disabled = false;
      }

      function pulsePath() {
        const speed = Number(pulseSpeed.value);
        if (pulseRunning) {
          clearPulse();
          status.textContent = "Pulse paused.";
          return;
        }

        if (!routePath || routePath.length === 0) {
          status.textContent = "No route to animate.";
          return;
        }

        let i = 0;
        clearPulse();
        pulseRunning = true;
        animateBtn.textContent = "Stop packet pulse";
        status.textContent = `Pulsing route (${routePath.length} hops).`;

        const step = () => {
          if (!pulseRunning || !routePath || routePath.length === 0) {
            clearPulse();
            return;
          }

          if (i > 0) {
            const prev = tileElements.get(key(routePath[i - 1].r, routePath[i - 1].c));
            if (prev) prev.classList.remove("flow");
          }

          if (i >= routePath.length) {
            const tail = tileElements.get(key(routePath[routePath.length - 1].r, routePath[routePath.length - 1].c));
            if (tail) tail.classList.remove("flow");
            if (packetMesh) packetMesh.visible = false;

            if (pulseLoop.checked && pulseRunning) {
              pulseTimer = setTimeout(() => {
                if (!pulseRunning) return;
                clearPulse();
                i = 0;
                step();
              }, 260);
              return;
            }

            status.textContent = "Packet delivered. Toggle regenerate for a new map.";
            animateBtn.textContent = "Pulse one packet path";
            pulseRunning = false;
            return;
          }

          const p = routePath[i++];
          const tile = tileElements.get(key(p.r, p.c));
          if (tile) tile.classList.add("path", "flow");
          setPacketPosition(i - 1);
          pulseTimer = setTimeout(step, speed);
        };

        step();
      }

      function updatePulseSpeedLabel() {
        if (!pulseSpeedLabel || !pulseSpeedValue) return;
        pulseSpeedLabel.textContent = "interval";
        pulseSpeedValue.textContent = `${Math.round(Number(pulseSpeed.value))}ms`;
      }

      function setView(view) {
        if (view !== "2d") {
          hideTileTooltip();
        }
        if (view === "3d" && !threeInited) {
          const ok = initThree();
          if (!ok) {
            view2dBtn.classList.add("active");
            view3dBtn.classList.remove("active");
            return;
          }
          rebuildThreeGrid();
        }

        currentView = view;
        document.body.classList.toggle("view-3d", view === "3d");
        document.body.classList.toggle("view-2d", view === "2d");
        svg.style.display = view === "3d" ? "none" : "block";
        canvas3d.style.display = view === "3d" ? "block" : "none";
        if (view === "3d") {
          resizeThree();
          if (threeInited) paint3DTiles();
        }
        view2dBtn.classList.toggle("active", view === "2d");
        view3dBtn.classList.toggle("active", view === "3d");
      }

      function redrawAll() {
        clearPulse();
        randomizeGrid();
        createLayout();
        drawMesh(showMesh.checked);
        paintTiles();
        defectValue.textContent = `${Math.round(currentRate * 100)}%`;
        defectLabel.textContent = `fault probability`;
        repairBudgetValue.textContent = `${Number(repairBudget.value)}%`;
        repairBudgetLabel.textContent = `spare-core remap budget (percent)`;
        linkDefectValue.textContent = `${Math.round(currentLinkRate * 100)}%`;
        linkDefectLabel.textContent = `fabric link fault probability`;
        repairBudget.disabled = !allowRepair.checked;
        updatePulseSpeedLabel();
        status.textContent = "Suggested flow: generate a new chip map, then pulse packet route.";
        reliabilityRate.textContent = "—";
        clearReliabilityFrame();

        if (threeInited) {
          rebuildThreeGrid();
        }
      }

      function onShowMeshChange() {
        if (currentView === "2d") {
          drawMesh(showMesh.checked);
        }
      }

      defectRate.addEventListener("input", redrawAll);
      repairBudget.addEventListener("input", redrawAll);
      allowRepair.addEventListener("change", redrawAll);
      linkDefectRate.addEventListener("input", redrawAll);
      pulseSpeed.addEventListener("input", updatePulseSpeedLabel);
      captureModeToggle.addEventListener("change", (event) => {
        setCaptureMode(event.target.checked);
      });
      runSimulationBtn.addEventListener("click", runYieldSimulation);
      autoRotate3dToggle.addEventListener("change", (event) => {
        threeAutoRotate = event.target.checked;
      });
      resetViewBtn.addEventListener("click", () => {
        if (!threeInited) {
          initThree();
        }
        resetThreeView();
      });
      showMesh.addEventListener("change", onShowMeshChange);
      shuffleBtn.addEventListener("click", redrawAll);
      animateBtn.addEventListener("click", pulsePath);
      view2dBtn.addEventListener("click", () => setView("2d"));
      view3dBtn.addEventListener("click", () => setView("3d"));
      window.addEventListener("resize", () => {
        if (currentView === "3d") resizeThree();
      });

      threeAutoRotate = autoRotate3dToggle ? autoRotate3dToggle.checked : false;
      setCaptureMode(true);
      redrawAll();
      setView("2d");
    </script>
  </body>
</html>
